# 外部项目学习笔记

**日期**：2026-02-28
**来源**：`<project_root>` 桌面 unreal-mcp-main 项目（上游参考实现）
**目的**：从上游实战项目中学习新模式、新命令、已知 Bug 修复、开发规范

---

## 1. 新增 C++ 功能（上游已实现，我们可参考）

### 1.1 `get_level_dirty_state` 命令

返回当前关卡的脏状态，用于预判关卡切换安全性：

```json
{
  "level_name": "NewMap",
  "package_name": "/Temp/Untitled",
  "is_dirty": true,
  "is_temp": true,
  "safe_to_switch": false
}
```

- `safe_to_switch = false` 仅当 `is_dirty AND is_temp`（无法静默保存）
- **我们已有**：`get_current_level_name`（无 dirty 信息），需考虑是否添加此命令

### 1.2 `new_level` 支持 `asset_path` 参数

```cpp
// 有路径：UEditorLevelLibrary::NewLevel(AssetPath)
// 无路径：GEditor->CreateNewMapForEditing()  → /Temp/Untitled
```

- 传 `asset_path="/Game/Maps/MyLevel"` 可直接创建有磁盘路径的关卡，避免临时关卡问题

### 1.3 `spawn_actor` 新增光照 Actor 类型

| actor_type | 头文件 |
|------------|--------|
| `DirectionalLight` | `Engine/DirectionalLight.h` |
| `SkyLight` | `Engine/SkyLight.h` |
| `SkyAtmosphere` | `Components/SkyAtmosphereComponent.h` |
| `ExponentialHeightFog` | `Engine/ExponentialHeightFog.h` |

**关键陷阱**：C++ `SpawnActor<ADirectionalLight>` 不自动设置 `bAtmosphereSunLight=true`。必须手动：
```python
set_actor_property(name="Sun_Light", property_name="bAtmosphereSunLight", property_value=True)
```

### 1.4 `set_actor_property` 组件属性回落

当属性在 Actor 上找不到时，自动遍历所有 `UActorComponent` 查找：

```cpp
bool bFound = SetObjectProperty(TargetActor, PropertyName, ...);
if (!bFound) {
    for (UActorComponent* Comp : TargetActor->GetComponents().Array())
        if (SetObjectProperty(Comp, PropertyName, ...)) { bFound = true; break; }
}
// 响应包含 "component": "LightComponent0"
```

### 1.5 `SilentSaveAllDirtyPackages()` 防弹框机制

在 `new_level`、`open_level` 切换前自动调用：

```cpp
FEditorFileUtils::SaveDirtyPackages(
    /*bPromptUserToSave=*/ false,
    /*bSaveMapPackages=*/ true,
    /*bSaveContentPackages=*/ true,  // 同时保存蓝图等内容资产
    false, false, false
);
```

`/Temp/` 包无磁盘路径时自动跳过（不触发 Save As）。

### 1.6 `spawn_blueprint_actor` 重名 Crash 修复

原始版本缺少重名检查导致 `LevelActor.cpp:585` Fatal Error。修复：在 `HandleSpawnBlueprintActor` 中添加与 `HandleSpawnActor` 相同的重名遍历检查。

---

## 2. 新增 Python 工具

### 2.1 `safe_switch_level`（level_tools.py）

```python
def safe_switch_level(ctx, asset_path=None):
    # 1. get_level_dirty_state → 检查 is_dirty + is_temp
    # 2. 若 dirty+temp → warning（C++ 已处理静默保存，但 /Temp/ 无法保存会有提示）
    # 3. 调用 open_level 或 new_level（C++ 侧已 SilentSaveAllDirtyPackages）
```

**推荐**：所有关卡切换场景用此工具代替直接调用 `new_level`/`open_level`。

### 2.2 `full_rebuild`（compile_tools.py）

一键完整流水线 MCP 工具：

```
Step 1: 快照路径 + 预保存所有资产（pre-save）
Step 2: Kill 所有 UnrealEditor.exe / CrashReportClientEditor.exe
Step 3: 等待进程退出 + 删除 PackageRestoreData.json 和 Saved/Autosaves/Temp/
Step 4: dotnet UnrealBuildTool.dll <Target> Win64 Development -Project=... -WaitMutex
Step 5: 重启编辑器 + 轮询 MCP 就绪（ping + get_current_level_name）
```

**注意**：LiveCoding（Tier3）不会重新调用 `RegisterCommands()`，新命令必须 full_rebuild。

### 2.3 `kill_editor`（compile_tools.py）

独立 MCP 工具，仅 Kill 编辑器（用于分步操作）。

---

## 3. 新增独立脚本

### 3.1 `scripts/full_rebuild.py`

无需 MCP 服务器即可运行的完整重建脚本：

```bash
uv run python scripts/full_rebuild.py [--no-launch] [--no-wait] [--config Development]
```

自动检测路径优先级：MCP `get_engine_path` → 参数 → 文件系统搜索。

### 3.2 `scripts/create_maze.py`

DFS 递归回溯算法生成迷宫，通过 MCP TCP 在 UE 中构建：
- `(2n+1)×(2n+1)` 网格，1=墙，0=通道
- 用 Blueprint Actor（MazeWallBP/MazeFloorBP）批量 spawn
- `safe_spawn_blueprint_actor` — 含 post-spawn scale 验证（检测 Blueprint 根组件 scale 丢失 Bug）
- 进度显示：`速率 walls/s + ETA`

---

## 4. Skill 系统（新发现）

上游项目在 `.claude/skills/<skill-name>/SKILL.md` 中定义可复用工作流。
我们已移植：

- `.claude/skills/create-basic-lighting-level/SKILL.md`

**SKILL.md 格式**：
```yaml
---
name: <skill-name>
description: 触发词列表（Claude 用于决定何时调用此 Skill）
version: 1.0.0
---
```

---

## 5. Python MCP 工具编写规范（来自 copilot-instructions）

| 规则 | 说明 |
|------|------|
| 禁止参数类型 | `Any`、`object`、`Optional[T]`、`Union[T]` |
| 有默认值参数 | `x: T = None`，在函数体内处理默认 |
| docstring | 必须，包含参数说明和有效输入示例 |

---

## 6. `MCPServerRunnable` 架构（上游新文件）

上游将 TCP 服务器循环提取为独立的 `FMCPServerRunnable : public FRunnable` 类：

```cpp
class FMCPServerRunnable : public FRunnable {
    UUnrealMCPBridge* Bridge;
    TSharedPtr<FSocket> ListenerSocket;
    void HandleClientConnection(TSharedPtr<FSocket> ClientSocket);
    void ProcessMessage(TSharedPtr<FSocket> Client, const FString& Message);
};
```

好处：将 TCP 逻辑与命令路由逻辑解耦。我们当前的实现在 Bridge 内，可参考此结构进行后续重构。

---

## 7. 关键 Bug 防御模式

### 7.1 临时关卡处理
```python
result = get_current_level_name()
level_path = (result.get("result") or {}).get("level_path", "")
if "/Temp/" in level_path:
    # 跳过 save_current_level，使用 safe_switch_level
```

### 7.2 force-kill + 重启的标准流程
1. 预保存（`save_current_level` + `save_all_assets`）
2. Kill 编辑器（psutil 或 taskkill）
3. 等待端口关闭（最多 30s）
4. 删除 `PackageRestoreData.json`（防 Recover Packages 弹框）
5. UBT 编译
6. 重启编辑器
7. 轮询就绪：`ping` + `get_current_level_name` 返回有效 `level_name`

### 7.3 spawn_blueprint_actor scale 丢失
Blueprint 根组件的 scale 在 SpawnActor 时可能被忽略。建议 post-spawn 验证 scale，或改用 `spawn_actor`（原生 Actor）后手动设置属性。
